% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colPoints.R
\name{colPoints}
\alias{colPoints}
\title{Points colored relative to third dimension}
\usage{
colPoints(x, y, z, data, add = TRUE, col = seqPal(cl$nbins), col2 = c(NA,
  "grey", "black"), Range = range(z, finite = TRUE),
  method = "equalinterval", breaks, sdlab = 1, legend = TRUE,
  legargs = NULL, hist = FALSE, histargs = NULL, lines = FALSE,
  nint = 30, xlab = substitute(x), ylab = substitute(y),
  zlab = substitute(z), las = 1, pch = 16, x1 = 0.6, y1 = 0.88,
  x2 = 0.99, y2 = 0.99, density = TRUE, quiet = FALSE, ...)
}
\arguments{
\item{x, y}{Vectors with coordinates of the points to be drawn}

\item{z}{z values belonging to coordinates. Vector or matrix with the color-defining height values}

\item{data}{Optional: data.frame with the column names as given by x,y and z.}

\item{add}{Logical. Should the points be added to current (existing!) plot? 
If FALSE, a new plot is started. DEFAULT: TRUE (It's called col\bold{Points}, after all)}

\item{col}{Vector of colors to be used. DEFAULT: 100 colors from sequential 
palette \code{\link{seqPal}} (color-blind safe, black/white-print safe)}

\item{col2}{Color for points where z is NA, or lower / higher than \code{Range}. DEFAULT: c(NA, 1, 8)}

\item{Range}{Ends of color bar. DEFAULT: range(z, finite=TRUE)}

\item{method}{Classification method (partial matching is performed), 
see \code{\link{classify}} (ways to get color breakpoints). DEFAULT: "equalinterval")}

\item{breaks}{Specification for method, see \code{\link{classify}}. 
DEFAULT: different defaults for each method}

\item{sdlab}{Type of label and breakpoints if \code{method=standarddeviation}, 
see \code{\link{classify}}. DEFAULT: 1}

\item{legend}{Logical. Should a \code{\link{colPointsLegend}} be drawn? DEFAULT: TRUE}

\item{legargs}{List. Arguments passed to \code{\link{colPointsLegend}}. 
DEFAULT: NULL, with some defaults specified internally}

\item{hist}{Logical. Should a \code{\link{colPointsHist}} be drawn? 
DEFAULT: FALSE (TRUE if histargs are given)}

\item{histargs}{List. Arguments passed to \code{\link{colPointsHist}}. DEFAULT: NULL}

\item{lines}{Logical. Should lines be drawn instead of / underneath the points? 
(color of each \code{\link{segments}} is taken from starting point, last point is endpoint.) 
If lines=TRUE and pch is not given, pch ist set to NA. DEFAULT: FALSE}

\item{nint}{Numeric of length 1. Number of interpolation points between each 
coordinate if \code{lines=TRUE}. nint=1 means no interpolation. 
Values below 10 will smooth coordinates and might miss the original points. DEFAULT: 30}

\item{xlab}{x-axis label. DEFAULT: \code{\link{substitute}(x)}}

\item{ylab}{y-axis label. DEFAULT: ditto}

\item{zlab}{\code{\link{colPointsLegend} title}. DEFAULT: ditto}

\item{las}{Label Axis Style. Only used when add=FALSE. See \code{\link{par}}. 
DEFAULT: 1 (all labels horizontal)}

\item{pch}{Point CHaracter. See \code{\link{par}}. DEFAULT: 16}

\item{x1, x2, y1, y2}{Relative coordinates [0:1] of inset plot, see \code{\link{smallPlot}}. 
Passed to \code{\link{colPointsLegend}}. DEFAULT: x: 0.6-0.99, y: 0.88-0.98}

\item{density}{Logical: plot density line in \code{\link{colPointsLegend}}? DEFAUTL: TRUE}

\item{quiet}{Turn off warnings? DEFAULT: FALSE}

\item{\dots}{Further graphical arguments passed to \code{\link{plot}}, 
\code{\link{points}} and \code{\link{lines}}, 
eg cex, xlim (when add=F), mgp, main, sub, asp (when add=F), etc. 
Note: col does not work, as it is already another argument}
}
\value{
Invisible list of values that can be passed to colPointsLegend or colPointsHist.
}
\description{
Draw colored points for 3D-data in a 2D-plane. Color is relative to third
dimension, by different classification methods. Can take 3 vectors or, as in
\code{\link{image}}, 2 vectors and a matrix for z.
}
\note{
Rstudio scales graphics really badly, so don't expect the right legend width out of the box if you use Rstudio! 
     Exporting via \code{png("myplot.png", 600,400); colPoints(x,y,z); dev.off()} usually works much better
}
\examples{

i <- c( 22,  40,  48,  60,  80,  70,  70,  63,  55,  48,  45,  40,  30,  32)
j <- c(  5,  10,  15,  20,  12,  30,  45,  40,  30,  36,  56,  33,  45,  23)
k <- c(175, 168, 163, 132, 120, 117, 110, 130, 131, 160, 105, 174, 190, 183)

# basic usage:
colPoints(i,j,k, cex=1.5, pch="+", add=FALSE)

# with custom Range:
colPoints(i,j,k, cex=1.5, pch="+", add=FALSE, Range=c(150,190), density=FALSE)
# can be used to allow comparison between several plots
# points outside the range are plotted with col2

# with custom colors:
mycols <- colorRampPalette(c("blue","yellow","red"))(50)
colPoints(i,j,k, cex=1.5, pch="+", add=FALSE, col=mycols)

# With legend title:
colPoints(i,j,k, cex=2, add=FALSE, zlab="Elevation [m above NN.]",
         legargs=list(density=FALSE))
?colPointsLegend # to see which arguments can be set via legargs

# with lines (nint to change number of linear interpolation points):
colPoints(i,j,k, cex=1.5, add=FALSE, lines=TRUE, nint=10, lwd=2)
# With NAs separating lines:
tfile <- system.file("extdata/rivers.txt", package="berryFunctions")
rivers <- read.table(tfile, header=TRUE, dec=",")
colPoints(x,y,n, data=rivers, add=FALSE, lines=TRUE)
colPoints(x,y,n, data=rivers, add=FALSE, lines=TRUE, pch=3)
colPoints(x,y,n, data=rivers, add=FALSE, lines=TRUE, pch=3, nint=2)

# different classification methods:
set.seed(007) ;  rx <- rnorm(30) ; ry <- rnorm(30) ; rz <- rnorm(30)*100
# sd: normal distribution
mycols <- colorRampPalette(c("blue","yellow", "red"))
colPoints(rx,ry,rz, add=FALSE, col=mycols(5), method="s",
          legargs=list(horiz=FALSE, x1=0.7, x2=0.95))
colPoints(rx,ry,rz, add=FALSE, col=mycols(6), method="s", sdlab=2,
          legargs=list(horiz=FALSE, labelpos=5, lines=FALSE, title=""))
# quantiles: each color is equally often used
colPoints(rx,ry,rz, add=FALSE, method="q",
          legargs=list(mar=c(0,1,1,0), bg="transparent") )
text(rx,ry,round(rz), col=8)
# logSpaced for rightly skewed data:
set.seed(41); rz2 <- rbeta(30, 1,7)*100
colPoints(rx,ry,rz2, add=FALSE, method="l", breaks=c(20,1.1708), col=mycols(20))
colPoints(rx,ry,rz2, add=FALSE, method="q", breaks=0:20/20, col=mycols(20),
          legargs=list(at=pretty2(rz2), labels=pretty2(rz2)) )

# With histogram:
colPoints(i,j,k, add=FALSE, hist=TRUE)
colPoints(i,j,k, cex=3.5, lwd=3, pch=1, histargs=list(bg=5, breaks=5), add=FALSE)
colPoints(rx,ry,rz, cex=3.5, lwd=3, pch=1, add=FALSE, legend=FALSE,
   histargs=list(mar=c(0,0,0,0), x1=0.5, x2=1, y1=0.8, y2=0.99, yaxt="n"))

# use classify separately:
text(rx,ry,round(rz), col=mycols(100)[classify(rz)$index], cex=0.7)

# histogram in lower panel:
layout(matrix(1:2), heights=c(8,4) )
colPoints(i,j,k, add=FALSE, legargs=list(y1=0.8, y2=1))
colPointsHist(z=k, x1=0.05, x2=1, y1=0, y2=0.4, mar=3, outer=TRUE)
layout(1)


# Customizing the legend :
cp <- colPoints(i,j,k, legend=FALSE, add=FALSE)
colPointsLegend(x1=0.2, x2=0.95, y1=0.50, y2=0.40, z=k, labelpos=5, atminmax=TRUE, bg=7)
colPointsLegend(x1=0.5, x2=0.90, y1=0.28, y2=0.18, z=k, Range=c(80, 200), nbins=12, font=3)
colPointsLegend(x1=0.1, x2=0.40, y1=0.15, y2=0.05, z=k, labelpos=5, lines=FALSE, title="")
colPointsLegend(z=k, horizontal=FALSE)
colPointsLegend(x1=0.01, y2=0.80, z=k, horizontal=FALSE, labelpos=4, cex=1.2)
colPointsLegend(x1=0.23, y2=0.95, z=k, horizontal=FALSE, labelpos=5, cex=0.8,
  dens=FALSE, title="", at=c(130,150,170), labels=c("y","rr","Be"), lines=FALSE)
# For method other than colPoints' default, it is easiest to include these
# options as a list in legargs, but you can also use the invisible output
# from colPoints for later calls to colPointsLegend
do.call(colPointsLegend, cp)
do.call(colPointsLegend, owa(cp, list(colors=rainbow2(100), cex=1.2)))

# colPoints with matrix:
colPoints(z=volcano, add=FALSE)
# image and contour by default transpose the matrix! 
# colPoints shows what is really in the data.
colPointsHist(z=volcano)

# highlight local character of points on a regular grid normally drawn with image:
z <- t(volcano)  ;  x <- 1:ncol(z)  ;  y <- 1:nrow(z)
colPoints(x,y,z, add=FALSE)  # takes matrix for z
contour(x,y,t(z), add=TRUE)

# image only takes a regular matrix, but not scatterpoints...
image(x,y,t(z), col=rainbow2(100))

# add single newly measured points to image (fictional data):
mx <- c( 22,  40,  80,  45,  60,  63,  30,  70)
my <- c(  5,  33,  12,  56,  20,  40,  45,  45)
mz <- c(135, 155, 120, 105, 140, 130, 190, 110)
colPoints(mx,my,mz, cex=5, pch="*", Range=c(94, 195), col=rainbow2(100), col2=NA, legend=FALSE)
points(mx,my, cex=4)
text(mx,my,mz, adj=-0.5, font=2)

# santiago.begueria.es/2010/10/generating-spatially-correlated-random-fields-with-r
if(require(gstat)){
xyz <- gstat(formula=z~1, locations=~x+y, dummy=TRUE, beta=1, 
             model=vgm(psill=0.025,model="Exp",range=5), nmax=20)
xyz <- predict(xyz, newdata=data.frame(x=runif(200, 20,40),y=runif(200, 50,70)), nsim=1)
head(xyz)
colPoints(x,y,sim1, data=xyz, col=rainbow2(100), add=FALSE)
}

}
\author{
Berry Boessenkool, \email{berry-b@gmx.de}, 2011-2014. I'd be interested in hearing what you used the function for.
}
\references{
\url{http://uxblog.idvsolutions.com/2011/10/telling-truth.html},
            \url{http://www.theusrus.de/blog/the-good-the-bad-22012/}
}
\seealso{
\code{\link{classify}}, \code{\link{colPointsLegend}}, \code{\link{colPointsHist}}
}
\keyword{aplot}
\keyword{color}
\keyword{hplot}

